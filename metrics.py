"""Prometheus metrics helper for the self-play system.

Provides consistent creation of metrics with either the global registry
(used when exposing /metrics via start_http_server) or an isolated
CollectorRegistry (used in tests to avoid duplicate metric registration).

Functions:
 - get_registry_and_start(port): returns registry (None for global) and
   starts the HTTP server if port is provided.
 - create_metrics(registry): returns a namespace (dict-like) of metric
   objects created in the given registry (or global if registry is None).

"""
from typing import Optional

try:
    from prometheus_client import Counter, Gauge, Histogram, CollectorRegistry, start_http_server
    PROMETHEUS_AVAILABLE = True
except Exception:
    PROMETHEUS_AVAILABLE = False


def get_registry_and_start(port: Optional[int]):
    """Return a CollectorRegistry (or None for the global registry).

    If a port is provided and Prometheus is available, start the
    HTTP server and return None (so metrics are registered in the global
    registry). If no port is provided, return an isolated CollectorRegistry
    (to avoid registering metrics globally in tests).
    """
    if not PROMETHEUS_AVAILABLE:
        return None

    if port:
        try:
            start_http_server(port)
        except Exception:
            # Best effort; continue without exposing server
            pass
        return None
    else:
        try:
            return CollectorRegistry()
        except Exception:
            return None


def create_metrics(registry: Optional[object]):
    """Create and return prometheus metrics bound to registry (or global).

    Returns a dict with keys: games_generated, games_saved, db_errors,
    game_errors, queue_length, db_latency.
    """
    if not PROMETHEUS_AVAILABLE:
        return None

    kwargs = {} if registry is None else {'registry': registry}

    metrics = {
        'games_generated': Counter('unit_games_generated_total', 'Games generated by selfplay', **kwargs),
        'games_saved': Counter('unit_games_saved_total', 'Games saved to DB', **kwargs),
        'db_errors': Counter('unit_db_errors_total', 'DB write errors', **kwargs),
        'game_errors': Counter('unit_game_errors_total', 'Game generation errors', **kwargs),
        'queue_length': Gauge('unit_write_queue_length', 'Current write queue length', **kwargs),
        'db_latency': Histogram('unit_db_write_latency_seconds', 'DB write latency seconds', **kwargs),
    }

    return metrics
